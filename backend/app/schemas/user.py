"""
Pydantic schemas for User entity.

These schemas define how user data should be validated and serialized
when crossing the API boundary. They're separate from the User model
because they serve different purposes - schemas are about the API contract,
models are about database persistence.
"""

from pydantic import BaseModel, EmailStr, Field, ConfigDict
from datetime import datetime
from typing import Optional


class UserBase(BaseModel):
    """
    Base schema containing fields common to multiple user schemas.
    
    This schema is never used directly but serves as a parent class
    for other user schemas. Inheritance lets us avoid repeating field
    definitions across multiple schemas.
    """

    # EmailStr is a special Pydantic type that validates email format
    # It checks that the string looks like an email address
    email: EmailStr = Field(..., description="User's email address for login and notifications")

    # full_name allows the display name to include spaces and special characters
    full_name: str = Field(..., min_length=1, max_length=100, description="User's full name")

    # The Field(...) means this field is required (no default value)
    # The Field function also lets us add descriptions that appear in API docs


class UserCreate(UserBase):
    """
    Schema for creating a new user.
    
    Inherits email and full_name from UserBase and adds fields specific
    to user creation. The password is required at creation but won't be
    stored directly - we'll hash it before saving to the database.
    """

    # Username must be unique, which is enforced at the database level
    # Here we just validate format and length
    username: str = Field(
        ...,
        min_length=3,
        max_length=50,
        pattern="^[a-zA-Z0-9_-]+$",  # Only alphanumeric, underscore, hyphen
        description="Unique username for login"
    )

    # Password must meet minimum security requirements
    # The pattern ensures at least 8 characters with mixed case and numbers
    password: str = Field(
        ...,
        min_length=8,
        max_length=100,
        description="User password (will be hashed before storage)"
    )

    # Role is optional at creation, defaults to 'researcher'
    # This allows admins to create users with different roles
    role: Optional[str] = Field(
        default='researcher',
        pattern="^(admin|researcher|viewer)$",
        description="User role determining permissions"
    )


class UserUpdate(BaseModel):
    """
    Schema for updating an existing user.
    
    All fields are optional because you might want to update just one field
    without providing all the others. Any field set to None means "don't change this".
    """

    # Optional allows None, which means "no update to this field"
    email: Optional[EmailStr] = Field(None, description="New email address")
    full_name: Optional[str] = Field(None, min_length=1, max_length=100)
    password: Optional[str] = Field(None, min_length=8, max_length=100)
    role: Optional[str] = Field(None, pattern="^(admin|researcher|viewer)$")
    is_active: Optional[bool] = Field(None, description="Whether the account is active")


class UserResponse(UserBase):
    """
    Schema for user data returned by the API.
    
    This includes all fields that should be visible to API clients.
    Note that password_hash is deliberately excluded for security.
    Generated fields like id and timestamps are included.
    """

    # These fields are generated by the database and only appear in responses
    id: int = Field(..., description="Unique user identifier")
    username: str = Field(..., description="Username for login")
    role: str = Field(..., description="User role (admin, researcher, viewer)")
    is_active: bool = Field(..., description="Whether the account is currently active")
    created_at: datetime = Field(..., description="When the account was created")
    updated_at: datetime = Field(..., description="When the account was last modified")

    # ConfigDict replaces the old Config class in Pydantic v2
    # from_attributes=True allows creating this schema from SQLAlchemy model instances
    # This is crucial - it tells Pydantic to read data from object attributes
    # rather than expecting a dictionary
    model_config = ConfigDict(from_attributes=True)


class UserLogin(BaseModel):
    """
    Schema for login requests.
    
    Separate from UserCreate because login only needs username and password,
    not the other fields required for registration.
    """

    username: str = Field(..., description="Username for authentication")
    password: str = Field(..., description="Password for authentication")