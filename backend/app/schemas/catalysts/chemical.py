"""
Pydantic schemas for Chemical entity.

Chemicals represent chemical compounds used in synthesis methods. The schemas
are relatively simple because chemicals have minimal attributes beyond their
name and timestamps.
"""

from pydantic import BaseModel, Field, ConfigDict
from datetime import datetime
from typing import Optional, List


class ChemicalBase(BaseModel):
    """
    Base schema for chemicals containing common fields.
    
    For chemicals, the only substantive field is the name. Everything else
    is either generated by the database (id, timestamps) or is relational
    (methods that use this chemical).
    """

    # Chemical name should be specific and unambiguous
    # Include relevant details like concentration, purity, or form
    # Examples: "Titanium(IV) isopropoxide 97%"
    #           "Ethanol absolute, â‰¥99.8%"
    #           "Ammonia solution 28-30%"
    name: str = Field(
        ...,
        min_length=1,
        max_length=255,
        description="Name of the chemical compound with relevant specifications",
        examples=[
            "Titanium(IV) isopropoxide",
            "Ethanol 99.5%",
            "Nitric acid 65%"
        ]
    )


class ChemicalCreate(ChemicalBase):
    """
    Schema for creating a new chemical.
    
    Inherits name from ChemicalBase. No additional fields needed because
    timestamps are auto-generated and relationships are managed through
    junction tables.
    """
    pass  # No additional fields needed for creation


class ChemicalUpdate(BaseModel):
    """
    Schema for updating a chemical.
    
    In practice, chemicals are rarely updated after creation because changing
    a chemical's name would affect all methods that reference it. You'd
    typically create a new chemical rather than modifying an existing one.
    However, the capability exists if needed for corrections.
    """

    name: Optional[str] = Field(
        None,
        min_length=1,
        max_length=255,
        description="Updated chemical name"
    )

class ChemicalSimple(ChemicalBase):
    """
    Simplified schema for nested representations.
    """
    id: int = Field(..., description="Unique identifier")
    model_config = ConfigDict(from_attributes=True)

class ChemicalResponse(ChemicalBase):
    """
    Schema for chemical data returned by the API.
    
    Includes all fields including generated ones. Can optionally include
    the list of methods that use this chemical, though for performance
    reasons that might only be included when specifically requested.
    """

    id: int = Field(..., description="Unique identifier")
    created_at: datetime = Field(..., description="When this chemical was added")
    updated_at: datetime = Field(..., description="When this record was last modified")

    # We could add a methods relationship here that would include the full
    # list of methods using this chemical:
    # methods: Optional[List["MethodResponse"]] = None
    # But we'll keep it simple for now and add relationship inclusion
    # as an enhancement later when we implement the router with include parameters
    
    methods: Optional[List["MethodSimple"]] = Field(
        default=None,
        description="List of chemicals used in this method (included when requested)"
    )

    model_config = ConfigDict(
        from_attributes=True,
        json_schema_extra={
            "examples": [
                {
                    "id": 1,
                    "name": "Titanium(IV) isopropoxide 97%",
                    "created_at": "2024-01-15T10:30:00Z",
                    "updated_at": "2024-01-15T10:30:00Z"
                }
            ]
        }
    )
    
# Import at the bottom to avoid circular dependencies
# This is a common pattern when schemas reference each other
from app.schemas.catalysts.method import MethodSimple

# Tell Pydantic to rebuild the model now that ChemicalResponse is available
# This resolves the forward reference "ChemicalResponse" in the chemicals field
ChemicalResponse.model_rebuild()
